# Redis 分布式锁学习

> **Author：** zss
>
> **Update：**2020/08/11
>
> **Desc: ** 学习Redis分布式锁的原理和使用

---

## 为什么需要分布式锁

**以下引用网上的资料**

随着业务越来越复杂，应用服务都会朝着分布式、集群的方向部署，而分布式CAP原则告诉我们，Consistency（一致性），Availability（可用性），Partition Tolerance（分区容错性）三者不可兼得。实践中一般满足CP或AP。很多场景中，需要使用分布式事务，分布式锁等技术来保证数据最终一致性。有的时候，我们**需要保证某一方法同一时刻只能被一个线程执行**。在单机环境中，多个线程可对共享变量进行访问时，我们可以简单的通过Java自身的同步操作来协调同一时刻对变量的串行访问。然而在分布式环境中，因为进程的独立性，进程之间无法访问相互之间的资源，无法像之前那样的方式实现进程锁，故需要一个独立的中心节点，以协调多个系统对共享变量的访问，所有进程在访问该变量时，都**从同一个地方进行取值并控制**，从而实现类似于单机环境中同步控制的效果。

## 思路

### 第一种

> 服务器*A*调用**SetNx**（key不重要，value也不重要，都随便），如果成功则获取锁（如果失败，那么说明已经有其他服务器获取了锁），其他服务器等待，业务处理完毕后，再通过**Del**释放锁
>
> 问题：如果服务器A在获取锁之后就挂掉了，也就是没有进行锁的释放，那么就会出现死锁现象，造成其他服务全都访问不了。
>
> 解决：给锁设置过期时间，如果超时，则自动释放锁
>
> 备注：在debug测试的时候出现一个问题，在setNx成功之后，del释放之前，我就手动把该进程关了，但是未被释放的锁竟然还在。
>
> ————原来是优雅的关闭进程的话，会自动删除redis，得强制关闭进程才行。

### 第二种

设置过期时间有两种方式

#### 1. 交给Redis去控制

>在这种情况下，value也不重要，可以随便设置
>
>服务器*A*首先调用**SetNx**，如果成功则获取锁（如果失败，则等待），接着使用**expire**给该锁设置过期时间，其他服务器等待，服务器A处理业务完毕后，再通过del释放锁，如果服务器A中途挂了，那么如果该锁过期了，则redis会自动删除也就是释放该锁，不至于造成死锁。
>
>问题：首先是原子性问题，setnx + expire这两个操作必须是原子性的。
>
>解决：1. 将释放过期了的锁的权利交给其他服务器；
>
>​			2. 使用**Lettuce**连接Redis，在Lettuce中，setnx和expire可以在一个方法中，如下。

```Java
public String setNxEx(String key, String value, Long ex) {
    StatefulRedisConnection<String, String> redis = redisPool.getRedis();
    if (redis != null) {
        RedisCommands<String, String> sync = redis.sync();
        SetArgs setArgs = SetArgs.Builder.nx().ex(ex);
        String set = sync.set(key, value, setArgs);
        redisPool.returnRedis(redis);
        return set;
    } else {
        return "";
    }
}
```

#### 2. 交给其他服务器去控制

> 这个时候，被我们冷落已久的value老弟总算派上用场了
>
> 服务器A首先依然调用**SetNx**（**value**为当前时间+过期时间），如果成功，那么顺利的获得锁，如果失败，则进行判断，调用**Get**方法获取Value，对value进行判断，如果小于当前的时间戳，则该锁已过期，那么可以获得锁，如果未过期，则任命，真正的获取锁失败。
>
> 问题：还是原子性问题，有可能有两个服务器甚至更多的服务器先后发现了锁过期，那么就可能出现这样的情况：服务器A和一个暴躁老哥*先后*发现了锁过期，服务器A获取了锁，这个暴躁老哥也获得了锁，都开始执行业务逻辑，然后先后执行释放锁的操作。也就是说可能会出现两个甚至更多的服务器获取到了锁，这个问题就太严重了。
>
> 解决：调用Redis的**GetSet**方法，该方法会在获取value的同时设置新的value。
>
> 改进后：**Get**获取到timeout1之后再调用**GetSet**获取timeout2，1和2进行比较，如果2是空的，那么说明锁已经被释放，如果1和2相等，那么说明在从get到getSet这个过程中间，没有别的服务器介入，也获得锁，然后就可以执行业务逻辑，再进行锁的释放。
>
> 小问题：改进后就会有个小问题，那就是服务器们每调用**GetSet**方法都会在原来的有效时间的基础上增加一些。不过这种影响还是比较小的，可以忽略不计，这算是一个小瑕疵吧。

### 第三种

> 使用**Redission**，在最流行的Redis分布式锁就是Redisson
>
> - 它对代码进行了精简的封装，我们的使用非常简单，甚至我们不用主动设置过期时间
> - 它设计了个watch dog看门狗，每隔10秒会检查一下是否还持有锁，若持有锁，就给他更新过期时间30秒；通过这样的设计，可以让他在没有释放锁之前一直持有锁，哪怕宕机了，也能自动释放锁
> - 而不能获得锁的客户端则是不断循环尝试加锁
> - 通过记录锁的客户端id，可以把它设计成可重入锁